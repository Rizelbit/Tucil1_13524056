\documentclass[a4paper, 12pt, onecolumn]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{amssymb}

\usepackage[margin=2.5cm]{geometry} 

\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{orange},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1
}

\begin{document}

\title{Laporan Tugas Kecil 1 IF2211 Strategi Algoritma \\ 
\Large Queens LinkedIn Solver}

\author{
    \IEEEauthorblockN{Reinhard Alfonzo Hutabarat -- 13524056} \\
    \IEEEauthorblockA{
        \textit{Program Studi Teknik Informatika}\\
        \textit{Sekolah Teknik Elektro dan Informatika}\\
        \textit{Institut Teknologi Bandung, Jalan Ganesha 10 Bandung}\\
        \textit{Email: reinhardalfonso@gmail.com, 13524056@std.stei.itb.ac.id}
    }
}

\maketitle

\thispagestyle{fancy}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyfoot[L]{\footnotesize Tugas Kecil 1 IF2211 Strategi Algoritma Teknik Informatika ITB Semester II Tahun 2025/2026}
\fancyfoot[R]{\thepage}

\tableofcontents
\newpage

\section{Deskripsi Permasalahan}
\textit{Queens} adalah sebuah permainan teka-teki logika yang dipopulerkan oleh platform LinkedIn. Permainan ini dimainkan di atas sebuah papan berukuran $N \times N$ kotak. Papan tersebut bukan sekadar berupa kotak kosong, melainkan terbagi menjadi beberapa wilayah atau blok yang direpresentasikan dengan warna-warna yang berbeda. Jumlah wilayah warna pada papan selalu sama dengan dimensi papan tersebut yaitu $N$ wilayah.

Tujuan utama dari permainan ini adalah menempatkan tepat $N$ buah Mahkota Ratu di atas papan sedemikian rupa sehingga memenuhi seluruh aturan keseimbangan berikut:
\begin{enumerate}
    \item Syarat Baris: Hanya boleh ada tepat satu Ratu di setiap baris.
    \item Syarat Kolom: Hanya boleh ada tepat satu Ratu di setiap kolom.
    \item Syarat Wilayah Warna: Hanya boleh ada tepat satu Ratu di dalam setiap blok warna yang sama.
    \item Syarat Ketetanggaan: Dua buah Ratu tidak boleh diletakkan saling bersentuhan satu sama lain, baik secara vertikal, horizontal, maupun secara diagonal.
\end{enumerate}

\section{Pendekatan Solusi}
\subsection{Algoritma Brute Force}
Algoritma Brute Force merupakan strategi pencarian sederhana yang menyelesaikan persoalan secara \textit{straigtforward}. Algoritma ini umumnya tidak cerdas atau tidak sangkil karena ia membutuhkan biaya komputasi yang besar dan lama dalam penyelesaiannya. Meskipun begitu, metode brute force menjamin menemukan solusi persoalan, jika ada. Strategi ini tidak menggunakan optimasi atau pendekatan heuristik. Mereka bergantung pada pengujian setiap hasil potensial tanpa mengesampingkan yang lain menggunakan pemangkasan cerdas atau heuristik.
\subsection{Memecahkan Persoalan Queens Menggunakan Algoritma Brute Force}
Penyelesaian teka-teki \textit{Queens} pada program ini diimplementasikan menggunakan algoritma \textit{Pure Brute Force} dengan pendekatan \textit{Generate and Test}. Program akan mencoba seluruh kemungkinan penempatan Ratu secara menyeluruh tanpa melakukan pemotongan cabang, lalu mengujinya di akhir untuk menemukan solusi yang valid. Secara konseptual, langkah-langkah pencarian ini dibagi menjadi tiga fase utama:
\begin{enumerate}
    \item Representasi Papan
    
    Untuk mengoptimalkan pencarian, papan tidak dipandang sebagai matriks dua dimensi. Mengingat aturan permainan mewajibkan hanya ada satu Ratu di setiap baris, ruang pencarian disederhanakan dengan memetakan letak Ratu ke sebuah \textit{array} satu dimensi. Pada representasi ini, indeks \textit{array} diartikan sebagai posisi baris, sedangkan nilai yang disimpan pada indeks tersebut menunjukkan posisi kolom tempat Ratu diletakkan.
    
    \item Fase Pembentukan
    
    Fase ini bertugas menyusun kombinasi letak Ratu dari baris pertama hingga baris terakhir menggunakan metode rekursif:
    \begin{itemize}
        \item Mulai dari baris pertama, letakkan Ratu di kolom pertama.
        \item Pindah ke baris berikutnya, letakkan Ratu di kolom pertama lagi.
        \item Jika pengisian baris selanjutnya telah selesai dieksplorasi atau sudah mentok, algoritma akan kembali ke baris sebelumnya dan menggeser letak Ratu ke kolom berikutnya di baris yang sama.
        \item Proses ini diulang terus-menerus hingga seluruh permutasi kolom di semua baris berhasil dibangkitkan.
    \end{itemize}
    
    \item Fase pengujian
    
    Pengujian validitas suatu posisi hanya dilakukan ketika seluruh Ratu telah diletakkan di atas papan. Program kemudian memvalidasi kombinasi tersebut terhadap tiga aturan:
    \begin{itemize}
        \item Syarat Kolom: Mengecek apakah ada dua Ratu yang berada di kolom yang sama.
        \item Syarat Ketetanggaan: Mengecek apakah ada Ratu yang saling bersentuhan, baik di sisi atas bawah maupun diagonal.
        \item Syarat Warna: Membaca warna wilayah tempat setiap Ratu berpijak. Jika ada dua Ratu yang berdiri di atas warna yang sama, kombinasi digugurkan.
    \end{itemize}
    Jika sebuah kombinasi lolos ketiga pengujian di atas, program akan langsung berhenti dan mengembalikan kombinasi tersebut sebagai solusi akhir.
\end{enumerate}

\section{Source Code Program}
Implementasi algoritma brute force pada program ini dibagi menjadi dua kelas utama yaitu kelas \textbf{Board} sebagai penyimpan keadaan papan dan aturan, serta kelas \textbf{Solver} sebagai mesin pencari solusi. Berikut adalah rincian dari fungsi-fungsi penting penyusun algoritmanya:
\subsection{\texttt{Board.java}}
Kelas ini bertugas menyimpan wujud fisik dari papan permainan dan memiliki fungsi untuk mengevaluasi apakah susunan Ratu di atas papan tersebut sah atau melanggar aturan.
    \begin{itemize}
        \item Representasi Keadaan
            
            Untuk menyimpan posisi Ratu, program tidak menggunakan matriks 2 dimensi tetapi program cukup menggunakan \textit{array} 1 dimensi bernama queenPos.
            
            \begin{lstlisting}[language=Java]
public class Board {
    int n;
    char[][] boardMap;
    int[] queenPos;
}
            \end{lstlisting}

            Pada representasi di atas, atribut $n$ digunakan untuk menyimpan ukuran dari papan permainan, lalu \textit{array} boardMap   yang berbentuk 2D bertugas untuk menyimpan peta warna asli dari file input. Indeks dari \textit{array} queenPos mewakili baris, sedangkan nilai yang disimpan di dalamnya mewakili kolom tempat Ratu diletakkan.
        \item Fungsi Evaluasi

            Dalam mengevaluasi atau memvalidasi aturan permainan, fungsi isBoardValid() bertugas untuk memindai susunan Ratu secara menyeluruh dan memastikan tidak ada satupun aturan permainan yang dilanggar.
            
            \begin{lstlisting}[language=Java]
public boolean isBoardValid() {
    boolean[] usedCol = new boolean[n];
    boolean[] usedColor = new boolean[256];

    for (int row = 0;row < n;row++) {
        int col = queenPos[row];

        if (usedCol[col]) {
            return false;
        }
        usedCol[col] = true;

        char color = boardMap[row][col];
        if (usedColor[color]) {
            return false;
        }
        usedColor[color] = true;

        if (row > 0) {
            int colQueenTop = queenPos[row-1];
            if (Math.abs(col - colQueenTop) <= 1) {
                return false;
            }
        }
    }

    return true;
}
            \end{lstlisting}
            
            Secara berurutan, fungsi di atas bekerja dengan langkah-langkah sebagai berikut:
            \begin{enumerate}
                \item Inisialisasi Memori: Program menyiapkan dua \textit{array} boolean kosong, yaitu usedCol untuk mencatat kolom mana saja yang sudah terisi oleh Ratu, dan usedColor untuk mencatat warna apa saja yang sudah sudah ditempati.
                \item Pemindaian Baris: Program melakukan perulangan dari baris pertama hingga baris terakhir untuk mengevaluasi posisi Ratu satu per satu.
                \item Pengecekan Syarat Kolom: Program membaca nilai kolom dari Ratu saat ini dan melihat ke dalam atribut usedCol. Apabila nilainya sudah bernilai \textit{true}, artinya ada Ratu lain di atasnya yang berada di kolom yang sama sehingga susunan langsung digagalkan. Jika belum, program akan menandai kolom tersebut menjadi \textit{true}.
                \item Pengecekan Syarat Warna: Program membaca matriks boardMap untuk mengetahui karakter warna tempat Ratu berpijak. Sama dengan pengecekan sebelumnya, jika warna tersebut sudah ditandai di dalam usedColor maka susunan akan digagalkan.
                \item Pengecekan Syarat Ketetanggaan: Mulai dari baris kedua, program membandingkan posisi Ratu saat ini dengan posisi kolom yang berada tepat di baris atasnya. Apabila absolut jarak kedua kolom tersebut bernilai 0 (sejajar vertikal) atau 1 (bersentuhan menyilang/diagonal), susunan digagalkan.
                \item Jika perulangan selesai dan tidak ada pelanggaran yang terdeteksi, program mengembalikan nilai \textit{true} yang menandakan bahwa susunan tersebut adalah solusi yang valid.
            \end{enumerate}
    \end{itemize}

\subsection{\texttt{Solver.java}}
Kelas ini bertugas mengeksekusi algoritma brute force murni untuk mencoba segala kemungkinan letak Ratu. Logika utamanya terletak pada fungsi rekursif solve().
    
    \begin{lstlisting}[language=Java]
public boolean solve(Board board, int currRow) {
    long countCase = 0;

    if (currRow == board.n) {
        countCase++;
        if (board.isBoardValid()) {
            return true;
        }
        return false;
    }

    for (int col = 0;col < board.n;col++) {
        board.queenPos[currRow] = col;
        boolean isSolutionFound = solve(board, currRow+1);

        if (isSolutionFound) {
            return true;
        }
    }
    return false;
}
    \end{lstlisting}

    Secara berurutan, algoritma pembentuk pada fungsi tersebut dijalankan dengan alur sebagai berikut:
    \begin{enumerate}
        \item Fase Pengujian: Pada awal fungsi, program memeriksa apakah baris saat ini sudah sama dengan dengan jumlah baris $n$. Kondisi ini menandakan bahwa Ratu telah diisi penuh hingga baris terakhir. Jika kondisi ini tercapai, program akan mencatat peninjauan satu kasus baru dan memanggil fungsi isBoardValid(). Jika valid, program akan mengembailkan nilai \textit{true}. Jika salah, program mengembalikan nilai \textit{false} agar pencarian kombinasi dilanjutkan.
        \item Fase Pembangkitan Kombinasi: Apabila papan belum penuh, program masuk ke dalam blok perulangan untuk mencoba menempatkan Ratu mulai dari kolom paling kiri hingga kolom paling kanan.
        \item Fase Pemanggilan Rekursif: Setelah itu Ratu diletakkan pada sebuah kolom di baris saat ini, program langsung memerintahkan dirinya sendiri secara rekursif untuk turun dan mengisi Ratu di bawahnya. Program sama sekali tidak mengecek ketepatan posisi saat masih berada di tenga-tengah perulangan ini.
        \item Fase Terminasi: Jika rekursi dari baris bawahnya berhasil menemukan solusi akhir, fungsi akan segera menghentikan perulangan dan meneruskan nilai \textit{true} tersebut ke atas. Namun jika ternyata gagal, program sekadar melanjutkan perulangan untuk menggeser letak Ratu di baris tersebut ke kolom sebelahnya.
    \end{enumerate}

\section{Analisis Kompleksitas}
Pendekatan Brute Force yang diimplementasikan berfokus pada eksplorasi secara \textit{exhaustive search}. Analisis kompleksitas waktunya dapat diuraikan sebagai berikut:
\begin{enumerate}
    \item Kompleksitas Fungsi Pembentuk
    
    Papan permainan memiliki ukuran $N \times N$, yang berarti terdapat $N$ baris yang masing-masing harus diisi oleh satu Ratu. Pada setiap baris, algoritma mencoba meletakkan Ratu di $N$ kemungkinan kolom yang ada.  Dengan dilakukannya proses ini secara rekursif untuk setiap baris, maka total kombinasi susunan papan yang akan dibangkitkan adalah $N^N$ kombinasi.

    \item Kompleksitas Fungsi Evaluasi
    
    Fungsi Evaluasi hanya dipanggil ketika $N$ Ratu telah diletakkan. Fungsi ini melakukan perulangan sebanyak $N$ kali untuk memeriksa setiap Ratu. Di dalam perulangan tersebut, operasi yang dilakukan hanyalah pengecekan ke dalam \textit{array} boolean dan operasi matematika dasar, yang masing-masing membutuhkan waktu konstan. Oleh sebab itu, kompleksitas waktu untuk satu kali pemanggilan fungsi evaluasi adalah $O(N)$.

\end{enumerate} 
Berdasarkan kedua hal tersebut, dapat disimpulkan skenario terburuk dan terbaiknya:
\begin{itemize}
    \item Kasus Terburuk
    
    Kasus terburuk terjadi ketika susunan solusi yang benar kebetulan berada pada kombinasi yang paling terakhir dihasilkan oleh fungsi pencari, atau ketika peta masukan tersebut memang sama sekali tidak memiliki solusi. Pada kondisi ini, algoritma terpaksa membangkitkan dan menguji seluruh $N^N$ kombinasi tanpa terkecuali. Akibat dari setiap pengujian membutuhkan waktu $O(N)$, maka kompleksitas waktu pada kasus terburuk adalah hasil dari keduanya, yaitu $O(N \cdot N^N)$ atau $O(N^{N+1})$.

    \item Kasus Terbaik
    
    Kasus Terbaik terjadi apabila susunan yang benar kebetulan berada pada kombinasi pertama yang dibentuk oleh fungsi pencari. Pada kondisi ini, algoritma hanya perlu melakukan rekursif sebanyak satu lintasan ke bawah dan langsung memanggil fungsi evaluasi satu kali. Karena saat evaluasi pertama tersebut program langsung mendapatkan nilai \textit{true}, pencarian dihentikan secara total. Oleh sebab itu, kompleksitas waktu pada kasus terbaik adalah linier, yaitu $\Omega (N)$.
\end{itemize}

\section{Hasil Pengujian}
Berikut adalah pengujian program menggunakan berbagai konfigurasi papan masukan beserta hasil visualisasinya.

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 1}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AABBB
        ACCBD
        ACEED
        AEEED
        AADDD
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc1.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 1}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 2}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AABBBAA
        AACBCDD
        AACBCDD
        AECCCFD
        AECCCFD
        EEGCFDD
        GEGDFDD
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc2.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 2}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 3}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AAABBCCC
        ABBBBBBC
        AABBBBCC
        ABBBBBBD
        EFBBBBGD
        EFFFGGGD
        EFHFGHGD
        EEHHHHDD
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc3.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 3}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 4}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AAABBCCCD
        ABBBBCECD
        ABBBDCECD
        AAABDCCCD
        BBBBDDDDD
        FGGGDDHDD
        FGIGDDHDD
        FGIGDDHDD
        FGGGDDHHH
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc4.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 4}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 5}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AAAA
        AABA
        CADA
        AAAA
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc5.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 5}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 6}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
                
            \end{verbatim}

            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc6.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 6}
\end{figure}

\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Test Case 7}} \\
        \hline
        \textbf{Input} & \textbf{Output} \\
        \hline
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \begin{verbatim}
        AAAAA
        BBBBB
        CCCCC
        DDDDD
        DDDDD
            \end{verbatim}
            
            \vspace{0.2cm}
        \end{minipage} 
        & 
        \begin{minipage}{0.45\textwidth}
            \centering
            \vspace{0.2cm}
            
            \includegraphics[width=0.9\linewidth]{outputtc7.png}
            
            \vspace{0.2cm}
        \end{minipage} \\
        \hline
    \end{tabular}
    \caption{Hasil Uji Coba Test Case 7}
\end{figure}

\section{Pranala Repository}
Seluruh kode sumber program dan \textit{test case} dapat diakses secara penuh melalui \textit{repository} GitHub pada tautan berikut: \\
\url{https://github.com/Rizelbit/Tucil1_13524056}

\vspace{2cm}
\begin{center}
    \fbox{
        \begin{minipage}{0.9\linewidth}
            \vspace{0.3cm}
            \textbf{Pernyataan} \\
            
            Tugas ini disusun sepenuhnya tanpa bantuan kecerdasan buatan (\textit{Generative AI}), melainkan hasil pemikiran dan analisis mandiri.
            
            \vspace{0.5cm}
            \begin{flushright}
                \includegraphics[width=4cm]{ttd.jpg} \\
                \vspace{0.2cm}
                Reinhard Alfonzo Hutabarat \\
                13524056
            \end{flushright}
            \vspace{0.3cm}
        \end{minipage}
    }
\end{center}

\clearpage
\section*{Lampiran}

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.8}
    \begin{tabular}{|c|p{10cm}|c|c|}
        \hline
        \textbf{No} & \multicolumn{1}{c|}{\textbf{Poin}} & \textbf{Ya} & \textbf{Tidak} \\ \hline
        1 & Program berhasil di kompilasi tanpa kesalahan & $\checkmark$ & \\ \hline
        2 & Program berhasil di jalankan & $\checkmark$ & \\ \hline
        3 & Solusi yang diberikan program benar dan mematuhi aturan permainan & $\checkmark$ & \\ \hline
        4 & Program dapat membaca masukan berkas .txt serta menyimpan solusi dalam berkas .txt & $\checkmark$ & \\ \hline
        5 & Program memiliki Graphical User Interface (GUI) & $\checkmark$ & \\ \hline
        6 & Program dapat menyimpan solusi dalam bentuk file gambar & $\checkmark$ & \\ \hline
    \end{tabular}
\end{table}

\end{document}